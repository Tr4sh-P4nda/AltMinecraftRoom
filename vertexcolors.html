<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>Shoo Shoo's Shooting Star</title>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r84/build/three.min.js"></script>
<script src="https://sdk.altvr.com/libs/altspace.js/1.0.0/altspace.min.js"></script>
<script src="https://cdn.rawgit.com/Ooblik/AltspaceVR-Native-Components-JS/master/js/JSNativeComponents.js"></script>
<script src="https://cdn.rawgit.com/norybiak/UltimateLoader/v0.3.0/dist/UltimateLoader.js"></script>
</head>
<body>

	<script>
		if (!window.altspace || !window.altspace.inClient) document.write('<h3>Bruh, This is an AltspaceVR app. Why you trying to open it in a browser? Get altspace here: <a href="http://altvr.com"> AltspaceVR </a></h3>');
		
		/*/////SHOO SHOO'S SHOOTING STAR - Environment by Ben Sumner - wacomalt@gmail.com
		///////Modeling done in Maya
		///////Lighting/Rendering done in Redshift
		///////Maya scale factor: 0.009249057236425
		*/
		
		var scene;
		
		var ShooShoosShootingStar = (function() {
			console.log("starting NightmareTime Space app");
			//Scene and renderer are the main stuff you need for altspace to have stuff to render, and to render it to the game
			scene = new THREE.Scene();
			var renderer = altspace.getThreeJSRenderer();

			//we use this to be able to easily scale our whole scene
			//var masterScale = 1;

			//Set a base folder for models
			var modelBaseUrl = 'assets/';
			var animationInc = 0;
			var world6_0;
			var world6_1;
			var world6_2;
			var world6_3;
			var meshCollider;

			//Create a variable for the user's head joint. It'll be filled later by "promises" and used for the snow system
			var userHead;

			//3D Models to load.
			var  models =
			[
				{ name: 'world6_0', type: '.gltf', position: { x: 0, y: 0, z: 0}, offset: { x: 0, y: 0, z: 0 } },
				{ name: 'world6_1', type: '.gltf', position: { x: 0, y: 0, z: 0}, offset: { x: 0, y: 0, z: 0 } },
				{ name: 'world6_2', type: '.gltf', position: { x: 0, y: 0, z: 0}, offset: { x: 0, y: 0, z: 0 } },
				{ name: 'world6_3', type: '.gltf', position: { x: 0, y: 0, z: 0}, offset: { x: 0, y: 0, z: 0 } },

			];

			//Kai made this function for the skybox
			function createSkybox(url, update, _opacity) {
				var _opacity = _opacity || false;
				var sphereGeo = new THREE.SphereGeometry(400, 20, 20, Math.PI + 0.3, -2*Math.PI);
				var texture = THREE.ImageUtils.loadTexture( url );

				texture.needsUpdate = update;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.format = THREE.RGBFormat;

				var config;
				if (_opacity)
				{
					config = { color: 0xffffff, map: texture, opacity: _opacity, transparent : true, side: THREE.DoubleSide };
				}
				else
				{
					config = { color: 0xffffff, map: texture, side: THREE.DoubleSide };
				}

				var sphereMaterial = new THREE.MeshBasicMaterial( config );

				return new THREE.Mesh(sphereGeo, sphereMaterial);
			}

			//Once the whole script has been read by altspace, do the model loader stuff
			function onLoaded() {
				for (var i = 0; i < models.length; i++)
				{
                    var obj = models[i].object;
                    var name = models[i].name;
                    var spawnPosition = new THREE.Vector3();

                    spawnPosition.copy(models[i].position);
                    //spawnPosition.multiplyScalar(masterScale);
                    obj.position.copy(spawnPosition);//initial position
                    //obj.scale.set(masterScale, masterScale, masterScale);

					//add the meshes to the scene
					scene.add(obj);
					
					if (name === 'world6_0') {
						obj.traverse( function(child) { if (child instanceof THREE.Mesh) {child.userData.altspace = {collider: {enabled: false}};}})
						obj.rotation.y = THREE.Math.degToRad(180);
						obj.position.set(0, -2, 36);
						obj.scale.setScalar(1.2);
						world6_0 = obj;
						
						scene.add(obj);
						console.log(obj);
						meshCollider = new NativeComponent('n-mesh-collider', {convex: false}, obj);
					}
					
					if (name === 'world6_1') {
						obj.traverse( function(child) { if (child instanceof THREE.Mesh) {child.userData.altspace = {collider: {enabled: false}};}})
						obj.rotation.y = THREE.Math.degToRad(180);
						obj.position.set(0, -2, 36);
						obj.scale.setScalar(1.2);
						world6_1 = obj;
						
						scene.add(obj);
						console.log(obj);
						meshCollider = new NativeComponent('n-mesh-collider', {convex: false}, obj);
					}
					
					if (name === 'world6_2') {
						obj.traverse( function(child) { if (child instanceof THREE.Mesh) {child.userData.altspace = {collider: {enabled: false}};}})
						obj.rotation.y = THREE.Math.degToRad(180);
						obj.position.set(0, -2, 36);
						obj.scale.setScalar(1.2);
						world6_2 = obj;
						
						scene.add(obj);
						console.log(obj);
						meshCollider = new NativeComponent('n-mesh-collider', {convex: false}, obj);
					}
					
					if (name === 'world6_3') {
						obj.traverse( function(child) { if (child instanceof THREE.Mesh) {child.userData.altspace = {collider: {enabled: false}};}})
						obj.rotation.y = THREE.Math.degToRad(180);
						obj.position.set(0, -2, 36);
						obj.scale.setScalar(1.2);
						world6_3 = obj;
						
						scene.add(obj);
						console.log(obj);
						meshCollider = new NativeComponent('n-mesh-collider', {convex: false}, obj);
					}
					
                }
            }

			function start() {

				//Promises are confusing, but its how we pull some info from altspace itself like the skeleton and enclosure info
				var promises =
					[
						altspace.getEnclosure(),
						altspace.getThreeJSTrackingSkeleton(),

					];

				//Stuff to run AFTER promises have been loaded (AKA most of the app goes here)
				Promise.all(promises).then(function (array)
				{
					//Store enclosure and skeleton promises to variables
					enclosure = array.shift();
					var skeleton = array.shift();

					//Add skeleton to scene and store Head joint in variable
					scene.add(skeleton);
					userHead = skeleton.getJoint('Head');

					// Build ultimateloader array
					var objectUrls = new Array(models.length);
					for (var i = 0; i < models.length; i++)
					{
						objectUrls[i] = modelBaseUrl + models[i].name + models[i].type;
					}

					// Use Kai's awesome UltimateLoader to load models
					UltimateLoader.multiload(objectUrls, function(objects)
					{
						for (var i = 0; i < objects.length; i++)
						{
							models[i].object = objects[i];
						}

						onLoaded();
					});

					//Create Skybox and add it to the scene.
					var skybox = createSkybox('assets/Sky_EchoAdventureA.jpg', true);
					
					scene.add(skybox);

					//Now that everything has been done, Run animation loop.
				(function animateYet(){
					if(world6_0){	//make sure these exist before animating
						animate();	//to prevent console errors
						return;
					};
					requestAnimationFrame(animateYet);
				}());

				}).catch(function (err)
				{
						console.log('Stuff is Broke', err);
						//General useless error message if all else fails.
					});
				}

			function animate() {

				//Increment my time counter variable
				animationInc++;
				
				//This tells JS to rerun this loop once one animation frame has happened. This is responsible for keeping a consistent timing to the animation regardless of framerate
				requestAnimationFrame(animate);
				
				//render the scene
				renderer.render(scene);
			

			}return { start: start };  //return this WHOLE thing to "start" which we will call once the enclosure opens or something
		}()); //End of actual app!

		//Whenever altspace loads the file, request fullspace, then run your actual app
		altspace.getEnclosure().then(function (enclosure) {
			enclosure.requestFullspace().then(function () {
			    ShooShoosShootingStar.start();
			});
		})
	</script>
</body>
</html>